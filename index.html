<!doctype html>
<html lang="zh">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WebXR Hand → Python Stream + 仿真显示</title>
<style>
  body { font-family: system-ui, sans-serif; padding: 24px; background: #111; color: #eee;}
  button { font-size: 16px; padding: 10px 16px; }
  #log { white-space: pre-wrap; margin-top: 12px; font-family: ui-monospace, monospace; }
  #sim { display:block; margin-top:10px; max-width:90vw; border:2px solid #333;}
</style>
<body>
  <h1>WebXR 手部关节采集 → WebSocket + 仿真画面显示</h1>
  <p>在 Quest 浏览器里打开本页，点击按钮进入 VR，并允许“手部追踪”。</p>
  <label>WSS 地址：
    <input id="ws" style="width: min(600px, 80vw)" value="wss://mournfully-fulvous-lashonda.ngrok-free.dev">
  </label>
  <div><button id="enter">进入 WebXR（手势）</button></div>
  <div id="log"></div>
  <img id="sim" alt="仿真画面将在这里显示">

<script>
// ===== 手部追踪（原样） =====
const MIN_JOINTS=21, GOOD_FRAMES_TO_LOCK=3, BAD_FRAMES_TO_LOSE=8;
const TRACK={left:{state:'LOST',good:0,bad:0}, right:{state:'LOST',good:0,bad:0}};
function gateTrack(h,good){
  const st=TRACK[h]||(TRACK[h]={state:'LOST',good:0,bad:0});
  if(good){st.good++;st.bad=0;if(st.state==='LOST'&&st.good>=GOOD_FRAMES_TO_LOCK)st.state='TRACKED';}
  else {st.bad++;st.good=0;if(st.state==='TRACKED'&&st.bad>=BAD_FRAMES_TO_LOSE)st.state='LOST';}
  return st.state==='TRACKED';
}
function transformPos(p){return{x:-p.z,y:-p.x,z:p.y};}
function quatMul(a,b){return{x:a.w*b.x+a.x*b.w+a.y*b.z-a.z*b.y,
                              y:a.w*b.y-a.x*b.z+a.y*b.w+a.z*b.x,
                              z:a.w*b.z+a.x*b.y-a.y*b.x+a.z*b.w,
                              w:a.w*b.w-a.x*b.x-a.y*b.y-a.z*b.z};}
function quatConj(q){return{x:-q.x,y:-q.y,z:-q.z,w:q.w};}
function quatNorm(q){const n=Math.hypot(q.x,q.y,q.z,q.w)||1;return{x:q.x/n,y:q.y/n,z:q.z/n,w:q.w/n};}
const qR={x:-0.5,y:0.5,z:0.5,w:-0.5}, qR_inv=quatConj(qR);
const JOINTS=["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip",
              "index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip",
              "middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip",
              "ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip",
              "pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"];

let wsSend=null, wsRecv=null;
let frameImageBitmap=null;

// ===== 面板参数（更大更近） =====
const PANEL_DISTANCE = 1.2;   // 更近
const PANEL_BASE_WIDTH = 2.2; // 基础宽度更大（米）
let panelW = PANEL_BASE_WIDTH;
let panelH = 1.3;             // 初始高度，收到帧后按比例自动更新
const PANEL_RX_DEG   = 0;

// 纹理方向（可按需改）
let ORIENT = 0;     // 0/90/180/270
let FLIP_X = false;
let FLIP_Y = true;

// ===== WebGL =====
let gl, texture, program3D, pos3DBuffer, uvBuffer;

// ===== 矩阵工具 =====
function deg2rad(d){return d*Math.PI/180;}
function mat4Identity(){return new Float32Array([1,0,0,0,  0,1,0,0,  0,0,1,0,  0,0,0,1]);}
function mat4Multiply(a,b){
  const out=new Float32Array(16);
  for(let r=0;r<4;r++){
    for(let c=0;c<4;c++){
      out[r*4+c]=a[r*4+0]*b[0*4+c]+a[r*4+1]*b[1*4+c]+a[r*4+2]*b[2*4+c]+a[r*4+3]*b[3*4+c];
    }
  }
  return out;
}
function mat4Translate(tx,ty,tz){
  const m=mat4Identity(); m[12]=tx; m[13]=ty; m[14]=tz; return m;
}
function mat4RotateX(rad){
  const c=Math.cos(rad), s=Math.sin(rad);
  return new Float32Array([1,0,0,0,  0,c,s,0,  0,-s,c,0,  0,0,0,1]);
}
// ★ 新增：通用 4×4 逆矩阵
function mat4Inverse(m){
  const a=new Float32Array(m);
  const inv=new Float32Array(16);
  inv[0]=a[5]*a[10]*a[15]-a[5]*a[11]*a[14]-a[9]*a[6]*a[15]+a[9]*a[7]*a[14]+a[13]*a[6]*a[11]-a[13]*a[7]*a[10];
  inv[4]=-a[4]*a[10]*a[15]+a[4]*a[11]*a[14]+a[8]*a[6]*a[15]-a[8]*a[7]*a[14]-a[12]*a[6]*a[11]+a[12]*a[7]*a[10];
  inv[8]=a[4]*a[9]*a[15]-a[4]*a[11]*a[13]-a[8]*a[5]*a[15]+a[8]*a[7]*a[13]+a[12]*a[5]*a[11]-a[12]*a[7]*a[9];
  inv[12]=-a[4]*a[9]*a[14]+a[4]*a[10]*a[13]+a[8]*a[5]*a[14]-a[8]*a[6]*a[13]-a[12]*a[5]*a[10]+a[12]*a[6]*a[9];
  inv[1]=-a[1]*a[10]*a[15]+a[1]*a[11]*a[14]+a[9]*a[2]*a[15]-a[9]*a[3]*a[14]-a[13]*a[2]*a[11]+a[13]*a[3]*a[10];
  inv[5]=a[0]*a[10]*a[15]-a[0]*a[11]*a[14]-a[8]*a[2]*a[15]+a[8]*a[3]*a[14]+a[12]*a[2]*a[11]-a[12]*a[3]*a[10];
  inv[9]=-a[0]*a[9]*a[15]+a[0]*a[11]*a[13]+a[8]*a[1]*a[15]-a[8]*a[3]*a[13]-a[12]*a[1]*a[11]+a[12]*a[3]*a[9];
  inv[13]=a[0]*a[9]*a[14]-a[0]*a[10]*a[13]-a[8]*a[1]*a[14]+a[8]*a[2]*a[13]+a[12]*a[1]*a[10]-a[12]*a[2]*a[9];
  inv[2]=a[1]*a[6]*a[15]-a[1]*a[7]*a[14]-a[5]*a[2]*a[15]+a[5]*a[3]*a[14]+a[13]*a[2]*a[7]-a[13]*a[3]*a[6];
  inv[6]=-a[0]*a[6]*a[15]+a[0]*a[7]*a[14]+a[4]*a[2]*a[15]-a[4]*a[3]*a[14]-a[12]*a[2]*a[7]+a[12]*a[3]*a[6];
  inv[10]=a[0]*a[5]*a[15]-a[0]*a[7]*a[13]-a[4]*a[1]*a[15]+a[4]*a[3]*a[13]+a[12]*a[1]*a[7]-a[12]*a[3]*a[5];
  inv[14]=-a[0]*a[5]*a[14]+a[0]*a[6]*a[13]+a[4]*a[1]*a[14]-a[4]*a[2]*a[13]-a[12]*a[1]*a[6]+a[12]*a[2]*a[5];
  inv[3]=-a[1]*a[6]*a[11]+a[1]*a[7]*a[10]+a[5]*a[2]*a[11]-a[5]*a[3]*a[10]-a[9]*a[2]*a[7]+a[9]*a[3]*a[6];
  inv[7]=a[0]*a[6]*a[11]-a[0]*a[7]*a[10]-a[4]*a[2]*a[11]+a[4]*a[3]*a[10]+a[8]*a[2]*a[7]-a[8]*a[3]*a[6];
  inv[11]=-a[0]*a[5]*a[11]+a[0]*a[7]*a[9]+a[4]*a[1]*a[11]-a[4]*a[3]*a[9]-a[8]*a[1]*a[7]+a[8]*a[3]*a[5];
  inv[15]=a[0]*a[5]*a[10]-a[0]*a[6]*a[9]-a[4]*a[1]*a[10]+a[4]*a[2]*a[9]+a[8]*a[1]*a[6]-a[8]*a[2]*a[5];
  let det=a[0]*inv[0]+a[1]*inv[4]+a[2]*inv[8]+a[3]*inv[12];
  if(det===0) return mat4Identity();
  det=1.0/det;
  for(let i=0;i<16;i++) inv[i]*=det;
  return inv;
}

// ===== 顶点/UV数据 =====
function buildPanelVertices(){
  const hw = panelW/2, hh = panelH/2;
  return new Float32Array([
    -hw,-hh,0,   hw,-hh,0,   -hw, hh,0,
    -hw, hh,0,   hw,-hh,0,    hw, hh,0
  ]);
}
function makeTexcoords(orient, flipX, flipY){
  let uv = [ 0,0, 1,0, 0,1,  0,1, 1,0, 1,1 ];
  function rot90(arr){ const out=[]; for(let i=0;i<arr.length;i+=2){ const u=arr[i],v=arr[i+1]; out.push(v,1-u);} return out; }
  let arr = uv;
  if(orient===90)  arr = rot90(arr);
  if(orient===180) arr = rot90(rot90(arr));
  if(orient===270) arr = rot90(rot90(rot90(arr)));
  for(let i=0;i<arr.length;i+=2){ if(flipX) arr[i]=1-arr[i]; if(flipY) arr[i+1]=1-arr[i+1]; }
  return new Float32Array(arr);
}
function uploadPanelVertices(){
  gl.bindBuffer(gl.ARRAY_BUFFER,pos3DBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, buildPanelVertices(), gl.STATIC_DRAW);
}
function applyTexcoords(){
  gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, makeTexcoords(ORIENT, FLIP_X, FLIP_Y), gl.STATIC_DRAW);
}

// ===== 根据图片尺寸自动放大面板 =====
function fitPanelToImage(img){
  if(!img || !img.width || !img.height) return;
  const aspect = img.width / img.height; // w/h
  panelW = PANEL_BASE_WIDTH;
  panelH = panelW / aspect;   // 等比例放大
  uploadPanelVertices();
}

function log(txt){console.log(txt);const el=document.getElementById('log');if(el)el.textContent=txt;}

// ===== WebSocket（原样）=====
function setupSockets(){
  const base=document.getElementById('ws').value;
  wsSend=new WebSocket(base);
  wsSend.onopen=()=>log("Send WS connected: "+base);
  wsRecv=new WebSocket(base+"/sub");
  wsRecv.onopen=()=>console.log("Recv WS connected: "+base+"/sub");
  wsRecv.onmessage=async ev=>{
    try{
      const data=JSON.parse(ev.data);
      if(data.frame){
        document.getElementById("sim").src="data:image/jpeg;base64,"+data.frame;
        const blob=await fetch("data:image/jpeg;base64,"+data.frame).then(r=>r.blob());
        frameImageBitmap=await createImageBitmap(blob, { imageOrientation:'none' });
        fitPanelToImage(frameImageBitmap); // ★ 收到帧后按比例放大面板
      }
    }catch(e){console.warn("WS parse error:",e);}
  };
}

// ===== GL 初始化（3D）=====
function initGLResources(gl){
  const vs3D=`
  attribute vec3 a_position;
  attribute vec2 a_texcoord;
  uniform mat4 u_viewProj;
  uniform mat4 u_model;
  varying vec2 v_uv;
  void main(){
    gl_Position = u_viewProj * u_model * vec4(a_position,1.0);
    v_uv = a_texcoord;
  }`;
  const fs=`
  precision mediump float;
  varying vec2 v_uv;
  uniform sampler2D u_texture;
  void main(){ gl_FragColor = texture2D(u_texture, v_uv); }`;

  function compile(type,src){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);return s;}
  const vsObj=compile(gl.VERTEX_SHADER,vs3D), fsObj=compile(gl.FRAGMENT_SHADER,fs);
  program3D=gl.createProgram();gl.attachShader(program3D,vsObj);gl.attachShader(program3D,fsObj);gl.linkProgram(program3D);

  pos3DBuffer=gl.createBuffer();  uploadPanelVertices();
  uvBuffer  =gl.createBuffer();  applyTexcoords();

  texture=gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D,texture);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);

  gl.useProgram(program3D);
  const uTexLoc = gl.getUniformLocation(program3D, "u_texture");
  if (uTexLoc) gl.uniform1i(uTexLoc, 0);

  // ★ 新增：为避免“单眼黑屏”，关闭背面剔除与深度测试
  gl.disable(gl.CULL_FACE);
  gl.disable(gl.DEPTH_TEST);
}

async function startXR(){
  setupSockets();
  if(!('xr' in navigator)){log("WebXR 不可用");return;}
  const ok=await navigator.xr.isSessionSupported('immersive-vr');
  if(!ok){log("immersive-vr 不受支持");return;}
  let session;
  try{
    session=await navigator.xr.requestSession('immersive-vr',{requiredFeatures:['local-floor'],optionalFeatures:['hand-tracking']});
  }catch(e){log("requestSession 失败："+e);return;}

  const canvas=document.createElement('canvas');
  gl=canvas.getContext('webgl',{xrCompatible:true});
  await gl.makeXRCompatible();
  session.updateRenderState({baseLayer:new XRWebGLLayer(session,gl)});
  initGLResources(gl);

  log("XR session started");
  const viewerSpace=await session.requestReferenceSpace('viewer');

  session.requestAnimationFrame(function onFrame(time,frame){
    const baseLayer=session.renderState.baseLayer;
    const viewerPose = frame.getViewerPose(viewerSpace);
    if (!viewerPose) { session.requestAnimationFrame(onFrame); return; }

    gl.bindFramebuffer(gl.FRAMEBUFFER,baseLayer.framebuffer);

    for (const view of viewerPose.views) {
      const vp = baseLayer.getViewport(view);
      gl.viewport(vp.x, vp.y, vp.width, vp.height);

      const proj = view.projectionMatrix;
      // ★ 改成我们自己的逆矩阵：保证双眼一致
      const viewMat = mat4Inverse(view.transform.matrix);
      const viewProj = mat4Multiply(proj, viewMat);

      let model = mat4Translate(0,0,-PANEL_DISTANCE);
      if (PANEL_RX_DEG !== 0){
        model = mat4Multiply(mat4RotateX(deg2rad(PANEL_RX_DEG)), model);
      }

      gl.useProgram(program3D);
      const uVP = gl.getUniformLocation(program3D,"u_viewProj");
      const uM  = gl.getUniformLocation(program3D,"u_model");
      gl.uniformMatrix4fv(uVP,false,viewProj);
      gl.uniformMatrix4fv(uM,false, model);

      gl.clearColor(0.05,0.05,0.05,1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      if(frameImageBitmap){
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D,texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,frameImageBitmap);

        const aPos = gl.getAttribLocation(program3D,"a_position");
        gl.bindBuffer(gl.ARRAY_BUFFER,pos3DBuffer);
        gl.enableVertexAttribArray(aPos);
        gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0);

        const aUV  = gl.getAttribLocation(program3D,"a_texcoord");
        gl.bindBuffer(gl.ARRAY_BUFFER,uvBuffer);
        gl.enableVertexAttribArray(aUV);
        gl.vertexAttribPointer(aUV,2,gl.FLOAT,false,0,0);

        gl.drawArrays(gl.TRIANGLES,0,6);
      }
    }

    // === 手部数据发送（原样） ===
    for(const source of session.inputSources){
      if(!source.hand) continue;
      const handed=source.handedness;
      const joints={}; let validCount=0;
      for(const j of JOINTS){
        const js=source.hand.get(j); if(!js) continue;
        const pose=frame.getJointPose(js,viewerSpace);
        if(!pose || pose.radius==null) continue;
        const P=transformPos(pose.transform.position);
        const q=pose.transform.orientation;
        const q2=quatNorm(quatMul(quatMul(qR,q),qR_inv));
        joints[j]={x:P.x,y:P.y,z:P.z,qx:q2.x,qy:q2.y,qz:q2.z,qw:q2.w,radius:pose.radius};
        validCount++;
      }
      if(!gateTrack(handed,validCount>=MIN_JOINTS)) continue;

      const out={t:time,space:'viewer',hand:handed,joints};
      if(wsSend&&wsSend.readyState===1)wsSend.send(JSON.stringify(out));
    }

    session.requestAnimationFrame(onFrame);
  });
}

document.getElementById('enter').addEventListener('click',startXR);
</script>
</body>
</html>
