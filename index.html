<!doctype html>
<html lang="zh">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WebXR 手部追踪 + 仿真显示</title>
<style>
  body { font-family: system-ui, sans-serif; background:#111; color:#eee; padding: 16px;}
  button { font-size: 16px; padding: 8px 14px; margin-top: 6px;}
  #log { margin-top: 12px; white-space: pre-wrap; font-family: ui-monospace, monospace;}
  #sim { width: 90vw; max-width: 1280px; display: block; margin-top: 10px; border: 2px solid #333; }
</style>
<body>
  <h1>WebXR 手部追踪 + 仿真显示</h1>
  <label>WS 地址：
    <input id="ws" style="width: min(600px, 80vw)" value="ws://YOUR-IP:8765/sub">
  </label>
  <button id="connect">仅连接WS</button>
  <button id="enter">进入 VR 并开始手势</button>
  <div id="log"></div>
  <img id="sim" alt="仿真画面将在这里显示">

<script>
// === 状态与工具 ===
const MIN_JOINTS=21, GOOD_FRAMES_TO_LOCK=3, BAD_FRAMES_TO_LOSE=8;
const TRACK={left:{state:'LOST',good:0,bad:0}, right:{state:'LOST',good:0,bad:0}};
function gateTrack(h, good){const s=TRACK[h]||(TRACK[h]={state:'LOST',good:0,bad:0});
  if(good){s.good++;s.bad=0;if(s.state==='LOST'&&s.good>=GOOD_FRAMES_TO_LOCK)s.state='TRACKED';}
  else{s.bad++;s.good=0;if(s.state==='TRACKED'&&s.bad>=BAD_FRAMES_TO_LOSE)s.state='LOST';}
  return s.state==='TRACKED';}
function transformPos(p){return {x:-p.z,y:-p.x,z:p.y};}
function quatMul(a,b){return{x:a.w*b.x+a.x*b.w+a.y*b.z-a.z*b.y,
  y:a.w*b.y-a.x*b.z+a.y*b.w+a.z*b.x,
  z:a.w*b.z+a.x*b.y-a.y*b.x+a.z*b.w,
  w:a.w*b.w-a.x*b.x-a.y*b.y-a.z*b.z};}
function quatConj(q){return {x:-q.x,y:-q.y,z:-q.z,w:q.w};}
function quatNorm(q){const n=Math.hypot(q.x,q.y,q.z,q.w)||1;return{x:q.x/n,y:q.y/n,z:q.z/n,w:q.w/n};}
const qR={x:-0.5,y:0.5,z:0.5,w:-0.5}, qR_inv=quatConj(qR);
const JOINTS=["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip",
"index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip",
"middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip",
"ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip",
"pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"];

let socket=null;
function log(txt){console.log(txt);document.getElementById('log').textContent=txt;}

function connectWS(){
  const url=document.getElementById("ws").value;
  log("Connecting to "+url);
  socket=new WebSocket(url);
  socket.onopen=()=>log("✅ WS connected to "+url);
  socket.onmessage=(ev)=>{
    try{
      const data=JSON.parse(ev.data);
      if(data.frame){
        console.log("[browser] got frame, len=",data.frame.length);
        document.getElementById("sim").src="data:image/jpeg;base64,"+data.frame;
      }
    }catch(e){console.warn("WS msg parse error:",e);}
  };
  socket.onerror=(e)=>console.error("WS error:",e);
  socket.onclose=()=>log("❌ WS closed");
}

document.getElementById("connect").addEventListener("click", connectWS);

// ---- WebXR + 手势追踪 ----
async function startXR(){
  if(!socket) connectWS(); // 确保已经连接
  if(!('xr' in navigator)){log("WebXR 不可用");return;}
  const ok=await navigator.xr.isSessionSupported('immersive-vr');
  if(!ok){log("immersive-vr 不受支持");return;}

  let session;
  try{
    session=await navigator.xr.requestSession('immersive-vr',{
      requiredFeatures:['local-floor'],
      optionalFeatures:['hand-tracking']
    });
  }catch(e){log("requestSession 失败："+e);return;}

  const canvas=document.createElement('canvas');
  const gl=canvas.getContext('webgl',{xrCompatible:true});
  await gl.makeXRCompatible();
  session.updateRenderState({baseLayer:new XRWebGLLayer(session,gl)});

  log("XR session started");
  const viewerSpace=await session.requestReferenceSpace('viewer');
  session.requestAnimationFrame(function onFrame(time,frame){
    for(const source of session.inputSources){
      if(!source.hand) continue;
      const handed=source.handedness;
      const joints={}; let validCount=0;
      for(const j of JOINTS){
        const js=source.hand.get(j);
        if(!js)continue;
        const pose=frame.getJointPose(js,viewerSpace);
        if(!pose||pose.radius==null)continue;
        const P=transformPos(pose.transform.position);
        const q=pose.transform.orientation;
        const q2=quatNorm(quatMul(quatMul(qR,q),qR_inv));
        joints[j]={x:P.x,y:P.y,z:P.z,qx:q2.x,qy:q2.y,qz:q2.z,qw:q2.w,radius:pose.radius};
        validCount++;
      }
      if(!gateTrack(handed,validCount>=MIN_JOINTS))continue;
      const out={t:time,space:'viewer',hand:handed,joints};
      if(socket&&socket.readyState===1){
        socket.send(JSON.stringify(out));
        console.log("[browser] sent joints frame, joints=",validCount);
      }
    }
    session.requestAnimationFrame(onFrame);
  });
}

document.getElementById("enter").addEventListener("click", startXR);
</script>
</body>
</html>
