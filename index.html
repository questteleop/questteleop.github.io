<!doctype html>
<html lang="zh">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WebXR Hand → Python Stream</title>
<style>
  body { font-family: system-ui, sans-serif; padding: 24px; }
  button { font-size: 16px; padding: 10px 16px; }
  #log { white-space: pre-wrap; margin-top: 12px; font-family: ui-monospace, monospace; }
</style>
<body>
  <h1>WebXR 手部关节采集 → WebSocket</h1>
  <p>在 Quest 浏览器里打开本页，点击下方按钮进入 VR，并允许“手部追踪”。</p>
  <label>WSS 地址：
    <input id="ws" style="width: min(600px, 80vw)" value="wss://undisposed-westin-unpromotable.ngrok-free.app">
  </label>
  <div><button id="enter">进入 WebXR（手势）</button></div>
  <div id="log"></div>

<script>
// === 1) 固定的坐标系旋转：viewer -> 你要的新系 ===
function transformPos(p) {
  // p: {x,y,z} in viewer
  // new: X'=-Z, Y'=-X, Z'=+Y
  return { x: -p.z, y: -p.x, z:  p.y };
}

// === 2) 四元数工具 ===
function quatMul(a, b) {
  // (ax,ay,az,aw) ⊗ (bx,by,bz,bw)
  return {
    x: a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,
    y: a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,
    z: a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w,
    w: a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z,
  };
}
function quatConj(q){ return {x:-q.x, y:-q.y, z:-q.z, w:q.w}; }
function quatNorm(q){
  const n = Math.hypot(q.x, q.y, q.z, q.w) || 1;
  return {x:q.x/n, y:q.y/n, z:q.z/n, w:q.w/n};
}

// === 3) 这个 q_R 就是把轴从 viewer 映射到你新系的固定旋转 ===
// 对应 R=[[0,0,-1],[-1,0,0],[0,1,0]]
const qR = { x:-0.5, y: 0.5, z: 0.5, w:-0.5 };
const qR_inv = quatConj(qR); // 单位四元数的逆就是共轭  
  
const JOINTS = [
  "wrist",
  "thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip",
  "index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip",
  "middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip",
  "ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip",
  "pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip",
];

const WS_URL = "wss://undisposed-westin-unpromotable.ngrok-free.app"; // ← 改成你的
let socket = null;
function log(txt){ console.log(txt); const el = document.getElementById('log'); if(el) el.textContent = txt; }

async function startXR(){
  if (!('xr' in navigator)) { log("WebXR 不可用（需 HTTPS/最新 Quest 浏览器）"); return; }

  // 连接 WebSocket（可选，不连也不会影响呈现）
  try { socket = new WebSocket(WS_URL); socket.onopen=()=>log("WS connected"); } catch(e){ log("WS 连接失败(可先忽略)："+e); }

  // 检查 immersive-vr 支持
  const ok = await navigator.xr.isSessionSupported('immersive-vr');
  if (!ok) { log("immersive-vr 不受支持"); return; }

  // 创建 Session（关键：后面会设置 XRWebGLLayer）
  let session;
  try{
    session = await navigator.xr.requestSession('immersive-vr', {
      requiredFeatures: ['local-floor'],
      optionalFeatures: ['hand-tracking'] // 要手部数据
    });
  }catch(e){
    log("requestSession 失败：" + e); return;
  }

  // ====== 关键补丁：创建 WebGL 并设置 XRWebGLLayer，防止“三个点” ======
  const canvas = document.createElement('canvas');          // 不必插到 DOM
  const gl = canvas.getContext('webgl', { xrCompatible: true, alpha:false, antialias:true });
  await gl.makeXRCompatible();
  session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
  // =====================================================================

  const refSpace = await session.requestReferenceSpace('local-floor');
  const viewerSpace = await session.requestReferenceSpace('viewer');
  log('XR session started');

  session.addEventListener('end', ()=>log('XR session ended'));

  const onFrame = (time, frame) => {
    const baseLayer = session.renderState.baseLayer;
    gl.bindFramebuffer(gl.FRAMEBUFFER, baseLayer.framebuffer);
    gl.clearColor(0.02, 0.02, 0.04, 1.0);                  // 随便清个背景
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);   // 只要清屏就算“呈现了”

    // 采手部数据并发回电脑
    for (const source of session.inputSources) {
      if (!source.hand) continue;
      const out = { t: time, space: 'viewer', hand: source.handedness, joints: {} };
      for (const j of JOINTS){
        const js = source.hand.get(j);
        if (!js) continue;
        const pose = frame.getJointPose(js, viewerSpace);
        if (!pose) continue;
        const p = pose.transform.position, q = pose.transform.orientation;
        // 位置：线性变换
        const P = transformPos(p);
        
        // 朝向：q' = qR ⊗ q ⊗ qR^{-1}
        const q2 = quatNorm(quatMul(quatMul(qR, q), qR_inv));
        out.joints[j] = { x:P.x, y:P.y, z:P.z, qx:q2.x, qy:q2.y, qz:q2.z, qw:q2.w, radius: pose.radius ?? null };
      }
      if (socket && socket.readyState === 1) socket.send(JSON.stringify(out));
    }

    session.requestAnimationFrame(onFrame);
  };
  session.requestAnimationFrame(onFrame);
}

document.getElementById('enter').addEventListener('click', startXR);
</script>
</body>
</html>
